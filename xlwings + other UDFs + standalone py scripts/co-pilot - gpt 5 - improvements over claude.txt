Critical issues to fix
1) Windows: raw/safe functions can’t distinguish failure from a real 0 value

In MASM raw (rdrand64_asm_raw), failure returns 0 in RAX. But a true random 64‑bit 0 is valid, so C cannot know if 0 means “success with zero” or “failure”. [0yt2k-my.s...epoint.com]
The C “raw” helper for Windows looks malformed and appears to call the assembly function twice inside a return expression (likely a copy/paste artifact), which is both incorrect and costly. [0yt2k-my.s...epoint.com]


Fix: Return success via the carry flag (CF) using SETC, and pass the value back via a pointer argument. Provide “try” functions that return an int success code.

Windows MASM (replace/add):
Assembly; int rdrand64_try(uint64_t* out)rdrand64_try PROC    ; RCX = out (Win64 first arg)    rdrand rax    setc dl           ; DL = 1 on success, 0 on failure    mov [rcx], rax    ; store the value    movzx eax, dl     ; return success as int    retrdrand64_try ENDP; int rdseed64_try(uint64_t* out)rdseed64_try PROC    rdseed rax    setc dl    mov [rcx], rax    movzx eax, dl    retrdseed64_try ENDPShow more lines
And safe (with retry):
Assembly; int rdrand64_safe_try(uint64_t* out)rdrand64_safe_try PROC    mov rdx, rcx      ; rdx=out    mov ecx, 10retry_rdrand:    rdrand rax    setc bl    mov [rdx], rax    movzx eax, bl    test eax, eax    jnz success    dec ecx    jnz retry_rdrand    xor eax, eax      ; return 0 on total failuresuccess:    retrdrand64_safe_try ENDP; int rdseed64_safe_try(uint64_t* out) -- mirror of aboverdseed64_safe_try PROC    mov rdx, rcx    mov ecx, 10retry_rdseed:    rdseed rax    setc bl    mov [rdx], rax    movzx eax, bl    test eax, eax    jnz success_seed    dec ecx    jnz retry_rdseed    xor eax, eaxsuccess_seed:    retrdseed64_safe_try ENDPShow more lines
Use these in C wrappers to return None or raise on total failure, while preserving 0 as a valid value.
2) C wrappers on Windows should use the new “try” functions
In randmodule.c, replace Windows‑specific rdrand64_raw/rdseed64_raw helpers with pointer‑based calls to the *_try functions above:
C#ifdef _WIN32#include <intrin.h>   // for __cpuid, etc.// externs from MASM:extern int rdrand64_try(uint64_t* out);extern int rdseed64_try(uint64_t* out);extern int rdrand64_safe_try(uint64_t* out);extern int rdseed64_safe_try(uint64_t* out);static inline int rdrand64_raw(uint64_t* val) {    return rdrand64_try(val);        // 1 on success, 0 on failure}static inline int rdseed64_raw(uint64_t* val) {    return rdseed64_try(val);}static inline int rdrand64_safe(uint64_t* val) {    return rdrand64_safe_try(val);}static inline int rdseed64_safe(uint64_t* val) {    return rdseed64_safe_try(val);}#endifShow more lines
This removes the zero/failure ambiguity and the accidental double RNG call. [0yt2k-my.s...epoint.com]
3) Inline asm correctness: clobbers and PAUSE in retry loops

Condition‑code clobber: Your GCC/Clang inline asm for Linux modifies flags but doesn’t declare "cc" as clobbered. Add it to each block. [0yt2k-my.s...epoint.com]
Retry etiquette: In tight retry loops (esp. for RDSEED), insert PAUSE (rep; nop) to be kinder to the pipeline and reduce SMT contention. Put it in both Linux C loops and Windows MASM safe loops. [0yt2k-my.s...epoint.com], [0yt2k-my.s...epoint.com]

Linux raw (example correction):
Cstatic inline int rdrand64_raw(uint64_t* val) {    unsigned char ok;    __asm__ __volatile__(        "rdrand %0; setc %1"        : "=r" (*val), "=qm" (ok)        :         : "cc"    );    return ok;}static inline int rdseed64_safe(uint64_t* val) {    int retries = 10;    while (retries--) {        if (rdseed64_raw(val)) return 1;        __asm__ __volatile__("pause" ::: "memory");    }    return 0;}Show more lines
 [0yt2k-my.s...epoint.com]
Windows MASM safe (insert PAUSE):
Assemblyretry_rdrand:    rdrand rax    setc bl    mov [rdx], rax    movzx eax, bl    test eax, eax    jnz success    pause              ; be polite to the core    dec ecx    jnz retry_rdrand``Show more lines
 [0yt2k-my.s...epoint.com]
4) CPUID detection: include proper headers and simplify

On Windows, include <intrin.h> and use __cpuidex. On GCC/Clang, prefer <cpuid.h>’s __get_cpuid helpers over raw inline asm, unless you have a reason to keep it. Claude’s current inline asm is fine but could be simplified. [0yt2k-my.s...epoint.com]


Build & packaging improvements


Non‑Windows compile flags

Consider restoring -march=native for best codegen on the build host (your original did that). [0yt2k-my.s...epoint.com]
If you stick with intrinsics, -mrdrnd -mrdseed are relevant; if you keep inline asm, they’re not needed. Currently you set both -mrdrnd and -mrdseed and use inline asm — safe, but redundant. [0yt2k-my.s...epoint.com]



Add -fPIC on Linux to be explicit for shared objects (some environments default it, others not). [0yt2k-my.s...epoint.com]


MASM toolchain guidance
Your error messaging for missing ml64 is great; consider documenting the exact Visual Studio workloads and Windows SDK version in README. [0yt2k-my.s...epoint.com]


Versioning and metadata
Keep versions consistent across setup.py and pyproject.toml (both show 2.1 now — good). Add license classifiers for PyPI if you intend to publish. [0yt2k-my.s...epoint.com]



API ergonomics & extras (optional)


Byte‑buffer helpers
Provide rdrand_bytes(n) that fills a Python bytes/bytearray using repeated RDRAND calls; choose raw vs. safe internally based on a mode argument.


Software fallback
If CPUID says unsupported, optionally fall back to os.urandom or secrets.token_bytes when users call the “safe” API, behind a feature flag. Your current behavior is “raise on unsupported”, which is perfectly valid; the fallback is about usability.


Expose success‑rate counters
For observability, track how many first‑try failures occur (especially useful under virtualization). You already do this in the test; consider an optional counter in the module.



Suggested patch (Windows + Linux highlights)

Windows MASM: replace raw/safe functions with *_try variants and insert PAUSE (as shown above).
C module (Windows section): use extern int *_try(uint64_t*) and update wrappers to return None or raise appropriately, avoiding the “zero means failure” problem. 
Linux inline asm: add "cc" clobbers and pause in safe loops. 
setup.py: add -fPIC on non‑Windows and decide between intrinsics vs inline asm (remove redundant flags accordingly). [0yt2k-my.s...epoint.com] [0yt2k-my.s...epoint.com], [0yt2k-my.s...epoint.com]


Why this matters for your “no‑loop raw” optimization
Claude’s idea to avoid looping in “raw” is sound and matches Intel’s guidance when you’re willing to handle occasional failure at a higher layer. But it only pays off if success detection is correct. On Linux, the inline asm uses SETC and returns ok — good. On Windows, you need the *_try ABI so the wrapper knows success independently of the returned value. After that fix, removing the loop in raw will reliably save those extra branches while preserving correctness. [0yt2k-my.s...epoint.com]


Codes:

Windows asam suggested by co-pilot GPT5:

; int rdrand64_try(uint64_t* out)
rdrand64_try PROC
    ; RCX = out (Win64 first arg)
    rdrand rax
    setc dl           ; DL = 1 on success, 0 on failure
    mov [rcx], rax    ; store the value
    movzx eax, dl     ; return success as int
    ret
rdrand64_try ENDP

; int rdseed64_try(uint64_t* out)
rdseed64_try PROC
    rdseed rax
    setc dl
    mov [rcx], rax
    movzx eax, dl
    ret
rdseed64_try ENDP

Safe with retries:

; int rdrand64_safe_try(uint64_t* out)
rdrand64_safe_try PROC
    mov rdx, rcx      ; rdx=out
    mov ecx, 10
retry_rdrand:
    rdrand rax
    setc bl
    mov [rdx], rax
    movzx eax, bl
    test eax, eax
    jnz success
    dec ecx
    jnz retry_rdrand
    xor eax, eax      ; return 0 on total failure
success:
    ret
rdrand64_safe_try ENDP

; int rdseed64_safe_try(uint64_t* out) -- mirror of above
rdseed64_safe_try PROC
    mov rdx, rcx
    mov ecx, 10
retry_rdseed:
    rdseed rax
    setc bl
    mov [rdx], rax
    movzx eax, bl
    test eax, eax
    jnz success_seed
    dec ecx
    jnz retry_rdseed
    xor eax, eax
success_seed:
    ret
rdseed64_safe_try ENDP

randmodule.c improved:

#ifdef _WIN32
#include <intrin.h>   // for __cpuid, etc.

// externs from MASM:
extern int rdrand64_try(uint64_t* out);
extern int rdseed64_try(uint64_t* out);
extern int rdrand64_safe_try(uint64_t* out);
extern int rdseed64_safe_try(uint64_t* out);

static inline int rdrand64_raw(uint64_t* val) {
    return rdrand64_try(val);        // 1 on success, 0 on failure
}
static inline int rdseed64_raw(uint64_t* val) {
    return rdseed64_try(val);
}
static inline int rdrand64_safe(uint64_t* val) {
    return rdrand64_safe_try(val);
}
static inline int rdseed64_safe(uint64_t* val) {
    return rdseed64_safe_try(val);
}
#endif

Linux explicit raw corrections:

static inline int rdrand64_raw(uint64_t* val) {
    unsigned char ok;
    __asm__ __volatile__(
        "rdrand %0; setc %1"
        : "=r" (*val), "=qm" (ok)
        : 
        : "cc"
    );
    return ok;
}

static inline int rdseed64_safe(uint64_t* val) {
    int retries = 10;
    while (retries--) {
        if (rdseed64_raw(val)) return 1;
        __asm__ __volatile__("pause" ::: "memory");
    }
    return 0;
}

MASM inserting PAUSE:

retry_rdrand:
    rdrand rax
    setc bl
    mov [rdx], rax
    movzx eax, bl
    test eax, eax
    jnz success
    pause              ; be polite to the core
    dec ecx
    jnz retry_rdrand
``
